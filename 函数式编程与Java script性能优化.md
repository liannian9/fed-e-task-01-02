# 函数式编程
## 函数式编程与面向对象编程
### 函数式编程：（functional programming)(FP)
   - 将现实世界事物与事物之间额联系抽象到程序世界（对运算过程的抽象）
   - 程序的本质:根据输入通过某种运算活动相应的输出，程序开发过程中会涉及很多有输入与输出的函数
   - 函数式编程中的函数指的不是程序中的函数（方法），而是数学中的函数即映射关系，例如 y = sin(x), x 与y的关系
   - 相同的输入要有相同的输出
   - 函数式编程用来描述数据之间的映射
### 面向对象编程：（object oriented programming）(OOP)
   - 将现实世界中的事物抽象成程序世界的类和对象，通过封装继承 多态来演示事物之间的联系
   - 特点：
### 面向过程编程：（procedure oriented Programming）（POP）
   - 分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用

### 函数式编程与面向对象编程的区别(计算机程序通常由两部分内容组成：数据和操作,在FP中，这两者通常由值和函数 来表示;在OOP中，我们把数据和操作定义在一个class中，通过类属性和类方法来表示)
   - 数据访问方式不一样
    + OOP:访问数据（全局变量除外），需要先获取对象的引用，然后在进行操作,所谓的对象其实就是函数式中的作用域
         所以也可以叫做作用域编程， 数据与操作逻辑合并到一起，形成一个封装
    + FP：访问是直接访问（通过函数入参或者作用域链查找），面向功能编程，函数可以访问的变量范围远远大于
         OOP，灵活性更高，但是OOP的约束性更强，本质是将数据与操作逻辑分开，然后各种组合
    ```
        //OOP
        class Foo {
            constructor() {
                this.bar = 0
            }
        }
        let foo = new Foo()
        foo.bar++
        //FP
        let bar = 0;
        function foo () {
            bar++
        }
        foo()
    ``` 
## 案例分析：

|          | 方法fn1    |  方法fn2  |  方法fn3  |
| -------- | -----:  | :----: | :----: |
| class1   |          |        |        |
| class2   |          |        |        |
| class3   |          |        |        |

### 目前我们使用面向对象与函数式编程分别实现以上功能
  - 面向对象编程：
    把 class1, class2, class3 抽象成了三个 class，然后分别给每个 class 加上 fn1, fn2, fn3 三个方法。这也是刚刚那句话的说法 面向对象编程把代码逻辑抽象成 class，然后给这些 class 一些操作，这里的主体是三个 class。
    + 面向对象编程是横向的填满了上的表格。
    + 在此可见OOP对问题的分解是由数据驱动的：它把问题分解成不同的由数据主导的类然后在类里面定义方法以实现需要的功能
  - 示例：
```
    class Father {
        fn1 () {

        }
        fn2 () {

        }
        fn3 () {

        }
    }
    class class1 extends Father {
        //重写父类方法
        fn1 () {

        }
        fn2 () {

        }
        fn3 () {

        }
    }
    class class2 extends Father {
        //重写父类方法
        fn1 () {

        }
        fn2 () {

        }
        fn3 () {

        }
    }
    class class3 extends Father {
        //重写父类方法
        fn1 () {

        }
        fn2 () {

        }
        fn3 () {

        }
    }
```
 - 函数式编程：
    这里的主体是三个操作，fn1, fn2 和 fn3，所以三个分别是一个函数，在函数里去实现三种变式怎么操作。
    + 函数式编程式纵向的填满了上面的表格。
    + FP对问题的分解是由操作驱动的，即把它分解成多个函数然后在函数内部分别处理不同的数据类型

 - 示例：

 ```
    fn1 (value) {
        switch(value)
            case class1: 代码块1;break;
            case class2: 代码块2;break;
            case class3: 代码块3;break;
                
    }
    fn2 (value) {
        switch(value)
            case class1: 代码块1;break;
            case class2: 代码块2;break;
            case class3: 代码块3;break;
                
    }
    fn3 (value) {
        switch(value)
            case class1: 代码块1;break;
            case class2: 代码块2;break;
            case class3: 代码块3;break;
                
    }
 ```
 ### 程序扩展比较：
   - 新增操作
    + FP:单独定义一个包含所有数据变种的的函数；
    + OOP:需要给每个类添加一个操作（需要修改所有的类）
   - 新增数据变种(class)
    + FP:需要给每个操作新增一个数据变种（需要修改所有有的操作）
    + OOP:根据新增的数据变种重新定义一个class
 ### 总结：
   - 函数式编程相当于按列填充这张表格，实现一个函数相当于把所有数据变种(variant)的同一操作都实现了
   - 面向对象式编程相当于按行填充，实现一个对象相当于把一个数据变种的所有不同操作都实现了。
   - 我们很难凭空地比较这两种不同编程范式地好坏，它们都是解决问题不同的正确的方式。就具体问题来说：如果我们有很多数据变种，少量的操作，函数式编程可能比较好些；反之则面相对象编程比较好些。
